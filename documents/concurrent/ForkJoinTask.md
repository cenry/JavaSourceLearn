# ForkJoinTask中文文档

## 文档翻译

在`ForkJoinPool`中运行的任务的抽象基类。`ForkJoinTask`是一个类似线程的实体，比一个正常的线程重量轻得多。在一个`ForkJoinPool`中，大量的任务和子任务可能由少量的实际线程来承载，这是以一些使用限制为代价的。

“主”`ForkJoinTask`在显式提交到一个`ForkJoinPool`时开始执行，或者，如果还没有涉及到ForkJoin计算，则通过`fork()`、`invoke()`或相关方法在`ForkJoinPool.commonpool()`中开始执行。一旦启动，它通常会依次启动其他子任务。从这个类的名称可以看出，许多使用`ForkJoinTask`的程序只使用`fork()`和`join()`方法，或者像`invokeAll`这样的派生方法。但是，这个类还提供了许多其他方法，它们可以在高级用法中发挥作用，以及支持新形式的fork/join处理的扩展机制。

`ForkJoinTask`是`Future`的轻量级形式，其执行效率源于一套限制（只有部分是静态可执行的），在这个限制下，它只在一个纯粹且独立的对象上执行计算任务。主要的协调机制是`fork()`和`join()`，前者安排异步执行，后者直到计算完任务的结果后才继续执行。理想情况下，计算应该避免同步方法或同步块，并且除了用同步器（例如与fork/join相配合的相位器）加入其他任务之外，还应该最小化其他的阻塞同步。可细分的任务也不应该执行阻塞I/O，理想情况下应该访问完全独立于其他正在运行的任务所访问的变量。通过不允许抛出已检查的异常(如IOExceptions)，但没那么严格。然而，计算可能仍然会遇到未检查的异常，这些异常会被重新抛出给试图加入它们的调用者。这些异常还可能包括由内部资源耗尽引起的`RejectedExecutionException`，比如分配内部任务队列失败。重新抛出的异常与常规异常的行为方式相同，也有可能包含堆栈跟踪(例如使用`ex.printStackTrace()`显示启动计算的线程和实际遇到异常的线程，至少会包含遇到异常的线程的异常。

使用可能阻塞的`ForkJoinTask`也是可以的，但要考虑几个点：

1. 如果任何其他任务要去依赖一个在外部被同步块或I/O阻塞的任务，那这个任务可能很难完成。那些从不执行join操作的，事件风格的异步任务（例如子类`CountedCompleter`）就是这种任务。
2. 为了最小化资源占用带来的影响，任务必须要小，理想情况下只执行阻塞操作。
3. 除非使用了`ForkJoinPool.ManagedBlocker`，否则，可能的阻塞任务数量肯定是小于任务池的`ForkJoinPool.getParallelism()`级别的，任务池不能保证有足够的线程可以用来确保任务的执行以及执行效率。

等待完成和提取任务结果的主要方法是`join()`，但是有几个变体：借由`Future`的特性，`Future.get()`方法支持以中断和/或定时的方式去完成任务并获得结果。方法`invoke()`在语义上等价于`fork();join();`但它总是会尝试在当前线程开始执行任务。这些方法的“quiet”形式不提取结果或报告异常，当执行一组任务，并且需要将结果或异常的处理延迟到全部完成时，可以用这种形式。`invokeAll`（在多个版本中可用）是最常见的并行执行方法：fork一系列的任务然后把它们都join。

一种比较典型的用法：一个fork-join对相当于是一个并行递归方法的一次调用(fork)和返回(join)。就像其他形式的递归调用那样，返回(join)应该是内层优先的。例如，`a.fork(); b.fork(); b.join(); a.join();`比`a.fork(); b.fork(); a.join(); b.join();`要有效得多。

可以用多个详细级别代表任务的执行状态：

- `isDone()`在任务完成（任何方式，包括任务没有执行就取消）的情况下为`true`。
- `isCompletedNormally() `在任务正常完成（没有被取消，也没有遭遇异常）的情况下为`true`。
- `isCancelled()`在任务被取消（这种情况下`getException()`会得到`CancellationException`）的情况下为`true。
- `isCompletedAbnormally()`在任务被取消或者遭遇异常时为`true`，这种情况下`getException()`会得到`CancellationException`或者它所遭遇到的异常。

`ForkJoinTask`类通常不直接子类化，你可以子类化一个抽象类，它支持一种特定的fork/join处理风格，例如：

- 对不返回结果的计算使用`RecursiveAction`。
- 对会返回结果的计算使用`RecursiveTask`。
- 对那些完成时会触发其他操作的计算使用`CountedCompleter`

通常，一个具体的`ForkJoinTask`子类声明包含其参数字段，在构造函数中建立，然后定义一个计算方法，以某种方式使用这个基类提供的控制方法。

方法`join()`及其变体仅适用于完成依赖项为非循环的情况，也就是说，并行计算可以描述为一个有向无环图(DAG)。否则，在任务循环地相互等待时，可能会遇到某种形式的死锁。不过这个框架支持其他方法和技术(例如使用Phaser、`helpQuiesce()`和`complete(V)`)，这些方法和技术可以用于为给那些静态结构不是DAG的问题构造自定义子类。为了支持这种用法，可以使用`setForkJoinTaskTag(short)`或`compareAndSetForkJoinTaskTag(short, short)`原子性地标记一个`short`值，并使用`getForkJoinTaskTag()`进行检查。`ForkJoinTask`的实现类们不会以任何目的使用这些受保护的方法或标记，但它们可能在一些特定的子类的构造中使用。例如，并行的图的遍历可以使用它提供的方法来避免重复访问已经处理过的节点/任务。（用于标记的方法名称有很多，这在一定程度上是为了鼓励开发者对方法的使用模式进行定义。）

为了那些与底层轻量级任务调度框架有内在联系的实现被复写，大多数基础方法都是final的。开发人员在创建自定义的fork/join机制时应该尽可能少地实现受保护的方法exec()、setRawResult(V)和getRawResult()，同时引入一个抽象的计算方法，可以在其子类中实现，可能要依赖于该类提供的其他受保护的方法。

`ForkJoinTask`应该执行相对少量的计算。大任务通常通过递归分解分解为更小的子任务。按照经验粗略地估计，一个任务应执行100~10000个基本的计算步骤，并且应该避免无限循环。如果任务太大，那么并行任务就不能提高吞吐量，如果太小，那么维护这些任务导致的额外的内存和性能开销就会得不偿失。

这个类为`Runnable`和`Callable`提供了`adapt`方法，当将`ForkJoinTask`的执行与其他类型的任务混合使用时，可以使用这些方法。当所有任务都是这种形式时，考虑使用asyncMode构造的任务池。

`ForkJoinTask`是可序列化的，这使他们能够用于扩展，如远程执行框架。正确的做法是只在执行之前或之后序列化任务，而不是在执行期间。在执行过程中不依赖序列化本身。

## 实现说明

`ForkJoinTask`主要负责在把任务中继给`ForkJoinWorkerThread`和`ForkJoinPool`中的方法时维护其自身的“status”字段。

这个类的方法或多或少会有这样的分层：

1. 基本状态维护
2. 执行和等待完成
3. 带有执行结果报告的用户级方法

这种层次可能比较难发现，因为我们将它的方法按照偏向javadocs的规则编排了。

`status`字段将运行控制状态位打包到一个`int`中，以最小化内存占用并确保原子性(通过CAS)。`status`最初为零，直到完成时才是非负的值，具体状态值和`DONE_MASK`执行与运算后结果为`NORMAL`, `CANCELLED`或`EXCEPTIONAL`。一个正在被其他线程阻塞等待的任务是带有`SIGNAL`状态的。一旦某个线程完成了带有`SIGNAL`状态的任务，所有等待者将被通过`notifyAll`方法唤醒。这里我们使用了内置的wait/notify机制来对JVM的监控功能加以利用，虽然不是最佳方案，但不这样做的话就要花更多的工夫去实现一套相同的机制。我们希望这个监控功能是严密的，就是说不希望通过偏向锁或无锁机制，所以这里我们用了一些奇怪的语言风格去实现它，基本上就是在每个同步块里面执行一个`wait`或`notifyAll`，或者两者都有。

目前这里的状态位只占据了高16位的部分位。低16位是留给开发者自定义标签用的。